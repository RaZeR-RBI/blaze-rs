<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>var data = {"files":[{"path":["/","home","razer","vscode-projects","blaze-rs","src","blend.rs"],"content":"use crate::internal::*;\n\nenum_from_primitive! {\n    #[cfg_attr(tarpaulin, skip)]\n    #[derive(Debug, PartialEq, Copy, Clone)]\n    /// Defines a blend factor (F_src or F_dst) for the blending equation:\n    ///\n    /// `C_result = C_src * F_src + C_dst * F_dst`\n    ///\n    /// Where:\n    /// * `C_result` - output color\n    /// * `C_src` - source color\n    /// * `F_src` - source blend factor\n    /// * `C_dst` - destination color (the one in the framebuffer)\n    /// * `F_dst` - destination blend factor\n    pub enum BlendFactor\n    {\n        /// Color is discarded (multiplied by 0)\n        Zero = GL_ZERO as isize,\n        /// Color is used as is (multiplied by 1)\n        One = GL_ONE as isize,\n        /// Color is multiplied by source color\n        SrcColor = GL_SRC_COLOR as isize,\n        /// Color is multiplied by (vec(1) - source color)\n        OneMinusSrcColor = GL_ONE_MINUS_SRC_COLOR as isize,\n        /// Color is multiplied by destination color\n        DstColor = GL_DST_COLOR as isize,\n        /// Color is multiplied by (vec(1) - destination color)\n        OneMinusDstColor = GL_ONE_MINUS_DST_COLOR as isize,\n        /// Color is multiplied by source alpha value\n        SrcAlpha = GL_SRC_ALPHA as isize,\n        /// Color is multiplied by (1 - source alpha)\n        OneMinusSrcAlpha = GL_ONE_MINUS_SRC_ALPHA as isize,\n        /// Color is multiplied by destination alpha value\n        DstAlpha = GL_DST_ALPHA as isize,\n        /// Color is multiplied by (1 - destination alpha)\n        OneMinusDstAlpha = GL_ONE_MINUS_DST_ALPHA as isize\n    }\n}\n\n#[derive(Debug, PartialEq, Copy, Clone)]\n/// Defines a pair of blend factors (F_src and F_dst) for the blending equation:\n/// \n/// `C_result = C_src * F_src + C_dst * F_dst`\n/// \n/// Where:\n/// * `C_result` - output color\n/// * `C_src` - source color\n/// * `F_src` - source blend factor\n/// * `C_dst` - destination color (the one in the framebuffer)\n/// * `F_dst` - destination blend factor\npub struct BlendMode\n{\n    /// Source blend factor\n    pub src: BlendFactor,\n    /// Destination blend factor\n    pub dst: BlendFactor\n}\n\n/// Normal blending mode (alpha-blend)\npub const NORMAL: BlendMode = BlendMode {\n    src: BlendFactor::SrcAlpha,\n    dst: BlendFactor::OneMinusSrcAlpha\n};\n\n/// Additive blending mode\npub const ADDITIVE: BlendMode = BlendMode {\n    src: BlendFactor::One,\n    dst: BlendFactor::One\n};\n\n/// Multiplicative blending mode\npub const MULTIPLY: BlendMode = BlendMode {\n    src: BlendFactor::DstColor,\n    dst: BlendFactor::Zero\n};\n\nimpl From<BlendMode> for BLZ_BlendFunc {\n    fn from(mode: BlendMode) -> BLZ_BlendFunc {\n        BLZ_BlendFunc {\n            source: mode.src as u32,\n            destination: mode.dst as u32\n        }\n    }\n}\n\n/// Sets the current blending mode to be used.\n/// Note - the blend mode is used when things actually get drawn on the screen,\n/// e.g. `SpriteBatch::present`, `StaticBatch::present` or `Immediate::draw`.\npub fn set_blend_mode(mode: BlendMode) {\n    unsafe { BLZ_SetBlendMode(mode.into()); }\n}\n","traces":[{"line":5,"address":4262128,"length":1,"stats":{"Line":0}},{"line":79,"address":4267760,"length":1,"stats":{"Line":1}},{"line":81,"address":4267779,"length":1,"stats":{"Line":1}},{"line":82,"address":4267783,"length":1,"stats":{"Line":1}},{"line":90,"address":4262048,"length":1,"stats":{"Line":1}},{"line":91,"address":4262068,"length":1,"stats":{"Line":1}}],"covered":5,"coverable":6},{"path":["/","home","razer","vscode-projects","blaze-rs","src","dynamic.rs"],"content":"use crate::internal::*;\nuse crate::texture::*;\nuse crate::*;\nuse std::marker::PhantomData;\n\n/// Defines a dynamic sprite batching object. \n///\n/// Designed for moving sprites.\n/// The sprites are batched into several configurable buckets which use VAOs \n/// (vertex array objects) and are drawn sorted by their texture to minimize \n/// texture state changes and increase performance. The VAOs are double-buffered\n/// by default, so they can be pushed faster without waiting for GPU to synchronize.\npub struct SpriteBatch<'a> {\n    raw: *mut BLZ_SpriteBatch,\n    _marker: PhantomData<&'a ()>,\n    options: SpriteBatchOpts,\n}\n\n/// Defines creation options for dynamic sprite batching object (SpriteBatch):\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct SpriteBatchOpts {\n    /// Maximum count of buckets (one bucket shares same texture)\n    pub max_buckets: u32,\n    /// Maximum count of sprites per bucket\n    pub max_sprites_per_bucket: u32,\n    /// Additional flags\n    pub flags: InitFlags,\n}\n\nbitflags! {\n    #[cfg_attr(tarpaulin, skip)]\n    /// Defines flags that can be used for SpriteBatch creation.\n    pub struct InitFlags: u32\n    {\n        /// Default flags\n        const Default = BLZ_InitFlags_DEFAULT;\n        /// Disables VAO buffering\n        const NoBuffering = BLZ_InitFlags_NO_BUFFERING;\n    }\n}\n\nimpl<'a> Drop for SpriteBatch<'a> {\n    fn drop(&mut self) {\n        unsafe {\n            BLZ_FreeBatch(self.raw);\n        }\n    }\n}\n\nimpl<'s> SpriteBatch<'s> {\n    /// Creates a new SpriteBatch object using specified parameters.\n    pub fn new(options: SpriteBatchOpts) -> Result<SpriteBatch<'s>, String> {\n        unsafe {\n            let ptr = BLZ_CreateBatch(\n                options.max_buckets as i32,\n                options.max_sprites_per_bucket as i32,\n                options.flags.bits(),\n            );\n            if ptr.is_null() {\n                return Err(try_get_err());\n            } else {\n                return Ok(SpriteBatch { raw: ptr, _marker: PhantomData, options: options });\n            }\n        }\n    }\n\n    /// Pushes a sprite into the batch using the specified parameters.\n    /// Returns error if the batch limits are reached.\n    ///\n    /// # Parameters\n    /// `texture` -\tSprite texture\n    /// `position` -\tPosition of the sprite (top-left corner if origin is NULL)\n    /// `srcRectangle` -\tPart of the source texture to draw defined in pixels, or NULL if the whole texture should be drawn\n    /// `rotation` -\tRotation of the sprite in clockwise direction in radians\n    /// `origin` -\tThe point around which the sprite should be positioned and rotated, if NULL, top-left corner (0, 0) will be used\n    /// `scale` -\tScale in X and Y directions, if NULL, defaults to (1,1)\n    /// `color` -\tColor to apply to the sprite (color gets multiplied if default shader is used)\n    /// `effects` -\tDefines if the sprite should be flipped in any direction \n    pub fn draw<'t: 's>(\n        &self,\n        texture: &'t Texture,\n        position: Vector2,\n        srcRectangle: Option<Rectangle>,\n        rotationInRadians: f32,\n        origin: Option<Vector2>,\n        scale: Option<Vector2>,\n        color: Color,\n        flip: SpriteFlip,\n    ) -> CallResult {\n        unsafe {\n            wrap_result(BLZ_Draw(\n                self.raw,\n                texture.raw,\n                position.into(),\n                srcRectangle.map(|r| r.into()).as_raw(),\n                rotationInRadians,\n                origin.map(|v| v.into()).as_raw(),\n                scale.map(|v| v.into()).as_raw(),\n                color.into(),\n                flip as u32,\n            ))\n        }\n    }\n\n    /// Lower-level drawing function, which allows specifying a custom quad to\n    /// be drawn. Used internally by the library.\n    pub fn lower_draw<'t: 's>(&self, texture: &'t Texture, quad: &SpriteQuad) -> CallResult {\n        let q: BLZ_SpriteQuad = quad.into();\n        unsafe { wrap_result(BLZ_LowerDraw(self.raw, texture.id, &q)) }\n    }\n\n    /// Flushes the batch onto the screen, drawing everything.    \n    pub fn present(&self) -> CallResult {\n        unsafe { wrap_result(BLZ_Present(self.raw)) }\n    }\n\n    /// Returns options which were used when this object was created.\n    pub fn get_options(&self) -> &SpriteBatchOpts {\n        &self.options\n    }\n}\n","traces":[{"line":30,"address":4256872,"length":1,"stats":{"Line":0}},{"line":43,"address":4251664,"length":1,"stats":{"Line":1}},{"line":45,"address":4251673,"length":1,"stats":{"Line":1}},{"line":52,"address":4251696,"length":1,"stats":{"Line":1}},{"line":54,"address":4251762,"length":1,"stats":{"Line":1}},{"line":55,"address":4251703,"length":1,"stats":{"Line":1}},{"line":56,"address":4251705,"length":1,"stats":{"Line":1}},{"line":57,"address":4251708,"length":1,"stats":{"Line":1}},{"line":59,"address":4251773,"length":1,"stats":{"Line":1}},{"line":60,"address":4251797,"length":1,"stats":{"Line":1}},{"line":61,"address":null,"length":0,"stats":{"Line":0}},{"line":62,"address":4251809,"length":1,"stats":{"Line":1}},{"line":79,"address":4251952,"length":1,"stats":{"Line":1}},{"line":91,"address":4252403,"length":1,"stats":{"Line":1}},{"line":92,"address":4252018,"length":1,"stats":{"Line":1}},{"line":93,"address":4252026,"length":1,"stats":{"Line":1}},{"line":94,"address":4252037,"length":1,"stats":{"Line":1}},{"line":95,"address":4252122,"length":1,"stats":{"Line":2}},{"line":96,"address":4252194,"length":1,"stats":{"Line":1}},{"line":97,"address":4252208,"length":1,"stats":{"Line":2}},{"line":98,"address":4252279,"length":1,"stats":{"Line":2}},{"line":99,"address":4252344,"length":1,"stats":{"Line":1}},{"line":100,"address":4252388,"length":1,"stats":{"Line":1}},{"line":107,"address":4252528,"length":1,"stats":{"Line":0}},{"line":108,"address":4252553,"length":1,"stats":{"Line":0}},{"line":109,"address":4252581,"length":1,"stats":{"Line":0}},{"line":113,"address":4252640,"length":1,"stats":{"Line":1}},{"line":114,"address":4252652,"length":1,"stats":{"Line":1}},{"line":118,"address":4252720,"length":1,"stats":{"Line":1}},{"line":119,"address":4252725,"length":1,"stats":{"Line":1}}],"covered":25,"coverable":30},{"path":["/","home","razer","vscode-projects","blaze-rs","src","immediate.rs"],"content":"use crate::internal::*;\nuse crate::texture::*;\nuse crate::*;\n\n/// Defines static methods used for immediate-mode drawing (which means that\n/// sprite is drawn immediately using one draw call).\n///\n/// When you need to draw a small number of sprites.\n/// The sprite is immediately drawn to the screen using the specified parameters. \n/// Can be useful for small amount of sprites where batching will not improve \n/// performance, or post-processing effects (to draw a fullscreen quad, for example).\npub struct Immediate {}\n\nimpl Immediate {\n    /// Immediately draws a sprite to the screen using specified parameters.\n    pub fn draw<'t>(\n        texture: &'t Texture,\n        position: Vector2,\n        srcRectangle: Option<Rectangle>,\n        rotationInRadians: f32,\n        origin: Option<Vector2>,\n        scale: Option<Vector2>,\n        color: Color,\n        flip: SpriteFlip,\n    ) -> CallResult {\n        unsafe {\n            wrap_result(BLZ_DrawImmediate(\n                texture.raw,\n                position.into(),\n                srcRectangle.map(|r| r.into()).as_raw(),\n                rotationInRadians,\n                origin.map(|v| v.into()).as_raw(),\n                scale.map(|v| v.into()).as_raw(),\n                color.into(),\n                flip as u32,\n            ))\n        }\n    }\n\n    /// Lower-level drawing function, which allows specifying a custom quad to\n    /// be drawn. Used internally by the library.\n    pub fn lower_draw<'t>(texture: &'t Texture, quad: &SpriteQuad) -> CallResult {\n        let q: BLZ_SpriteQuad = quad.into();\n        unsafe { wrap_result(BLZ_LowerDrawImmediate(texture.id, &q)) }\n    }\n}\n","traces":[{"line":16,"address":4243040,"length":1,"stats":{"Line":1}},{"line":27,"address":4243447,"length":1,"stats":{"Line":1}},{"line":28,"address":4243084,"length":1,"stats":{"Line":1}},{"line":29,"address":4243092,"length":1,"stats":{"Line":1}},{"line":30,"address":4243166,"length":1,"stats":{"Line":1}},{"line":31,"address":4243238,"length":1,"stats":{"Line":1}},{"line":32,"address":4243252,"length":1,"stats":{"Line":1}},{"line":33,"address":4243323,"length":1,"stats":{"Line":1}},{"line":34,"address":4243388,"length":1,"stats":{"Line":1}},{"line":35,"address":4243432,"length":1,"stats":{"Line":1}},{"line":42,"address":4243568,"length":1,"stats":{"Line":1}},{"line":43,"address":4243588,"length":1,"stats":{"Line":1}},{"line":44,"address":4243616,"length":1,"stats":{"Line":1}}],"covered":13,"coverable":13},{"path":["/","home","razer","vscode-projects","blaze-rs","src","lib.rs"],"content":"#![deny(missing_docs)]\n#![allow(non_upper_case_globals)]\n#![allow(non_camel_case_types)]\n#![allow(non_snake_case)]\n\n//! This crate wraps the [blaze library](https://github.com/razer-rbi/blaze)\n//! which is geared towards efficient and cross-platform 2D sprite drawing using OpenGL.\n//! Supported features:\n//! * Dynamic batched sprite drawing\n//! * Static batched sprite drawing\n//! * Immediate drawing\n//! * Texture loading\n//! * Render targets\n//! * Custom shaders\n//! * Screenshot saving\n\n#[macro_use]\nextern crate bitflags;\nextern crate bytes;\n#[macro_use]\nextern crate enum_primitive;\n\n/// Defines blending-related functionality.\npub mod blend;\n/// Dynamic batched drawing. Designed for moving sprites.\npub mod dynamic;\n/// Immediate-mode drawing.\npub mod immediate;\n/// Render target support.\npub mod rendertarget;\n/// Custom shader support.\npub mod shader;\n/// Static batched drawing. Designed for static geometry.\npub mod r#static;\n/// Texture loading and saving.\npub mod texture;\n\n#[cfg_attr(tarpaulin, skip)]\nmod internal;\n\nuse crate::internal::wrap_result;\n\n/// A rectangle which has it's top-left corner position, width and height expressed in floats.\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct Rectangle {\n    /// X position of top left corner\n    pub x: f32,\n    /// Y position of top left corner\n    pub y: f32,\n    /// Width\n    pub w: f32,\n    /// Height\n    pub h: f32,\n}\n\n/// Underlying sprite quad data structure used by VAOs (vertex array objects).\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct SpriteQuad {\n    /// Four vertices defining the quad, defined in the following order:\n    /// 0 - top-left, 1 - bottom-left, 2 - top-right, 3 - bottom-right\n    /// (think of N flipped horizontally, like И)\n    pub vertices: [Vertex; 4usize],\n}\n\n/// Two-dimensional float vector.\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct Vector2 {\n    /// X coordinate\n    pub x: f32,\n    /// Y coordinate\n    pub y: f32,\n}\n/// Four-dimensional float vector.\n#[repr(C)]\n#[derive(Debug, Copy, Clone)]\npub struct Vector4 {\n    /// X coordinate\n    pub x: f32,\n    /// Y coordinate\n    pub y: f32,\n    /// Z coordinate\n    pub z: f32,\n    /// W coordinate\n    pub w: f32,\n}\n\n/// Underlying vertex data structure used by VAOs (vertex array objects).\n#[repr(C, packed)]\n#[derive(Debug, Copy, Clone)]\npub struct Vertex {\n    /// X position on the screen\n    pub x: f32,\n    /// Y position on the screen\n    pub y: f32,\n    /// Texture coordinate (U)\n    pub u: f32,\n    /// Texture coordinate (V)\n    pub v: f32,\n    /// Color (R)\n    pub r: f32,\n    /// Color (G)\n    pub g: f32,\n    /// Color (B)\n    pub b: f32,\n    /// Color (alpha)\n    pub a: f32,\n}\n\nuse internal::*;\nuse std::ffi::*;\nuse std::os::raw::*;\nuse std::string::*;\n\n/// Represents a RGBA color.\n#[derive(Debug, Copy, Clone)]\npub struct Color {\n    /// Red component, defined in range from 0.0 to 1.0\n    pub r: f32,\n    /// Green component, defined in range from 0.0 to 1.0\n    pub g: f32,\n    /// Blue component, defined in range from 0.0 to 1.0\n    pub b: f32,\n    /// Alpha component, defined in range from 0.0 to 1.0\n    pub a: f32,\n}\n\n#[cfg_attr(tarpaulin, skip)]\nimpl From<Vector4> for Color {\n    fn from(vector: Vector4) -> Self {\n        Color { r: vector.x, g: vector.y, b: vector.z, a: vector.w }\n    }\n}\n\n#[cfg_attr(tarpaulin, skip)]\nimpl From<Color> for Vector4 {\n    fn from(color: Color) -> Self {\n        Vector4 { x: color.r, y: color.g, z: color.b, w: color.a }\n    }\n}\n\nenum_from_primitive! {\n    /// Defines supported flip modes that can be used when the sprite is drawn.\n    #[cfg_attr(tarpaulin, skip)]\n    #[derive(Debug, Copy, Clone)]\n    pub enum SpriteFlip\n    {\n        /// Draws the sprite texture as it is\n        None = BLZ_SpriteFlip_NONE as isize,\n        /// Flips the texture horizontally\n        FlipH = BLZ_SpriteFlip_FLIP_H as isize,\n        /// Flips the texture vertically\n        FlipV = BLZ_SpriteFlip_FLIP_V as isize,\n        /// Flips the texture both horizontally and vertically\n        Both = BLZ_SpriteFlip_BOTH as isize\n    }\n}\n\n/// Defines a type for OpenGL procedure loader.\npub type GLProcLoader = unsafe extern \"C\" fn(name: *const c_char) -> *mut c_void;\n/// Alias for `Result<(), String>`.\npub type CallResult = Result<(), String>;\n\n/// Returns last API error information string. The same string is returned from\n/// API calls which return `Result<..., String>`.\n/// Note: error string may be empty even if an API call failed, the output\n/// `Result<..., String>` will return an `Err(\"Unknown error\")` in that case.\npub fn get_last_error() -> Option<String> {\n    unsafe {\n        let ptr = BLZ_GetLastError().as_ref();\n        ptr.map(|val| CStr::from_ptr(val).to_str().unwrap().to_owned())\n    }\n}\n\n/// Loads OpenGL functions used by this library. Requires an active window with\n/// an OpenGL context (version 3.0 core and above).\n/// # Example (using SDL2)\n/// ```\n///    use blaze_rs::load;\n///    use sdl2::video::GLProfile;\n///\n///    let context = sdl2::init().unwrap();\n///    let video_sys = context.video().unwrap();\n///    let gl_attr = video_sys.gl_attr();\n///    gl_attr.set_context_profile(GLProfile::Core);\n///    gl_attr.set_context_version(3, 0);\n///    let window = video_sys.window(\"Test\", 800, 600)\n///        .opengl()\n///        .build()\n///        .unwrap();\n///    let _ctx = window.gl_create_context().unwrap();\n///\n///    match load(sdl2::sys::SDL_GL_GetProcAddress) {\n///        Ok(_) => {}\n///        Err(e) => panic!(e),\n///    }\n/// ```\npub fn load(loader: GLProcLoader) -> CallResult {\n    unsafe {\n        match BLZ_Load(Some(loader)) {\n            x if x > 0 => Ok(()),\n            _ => panic!(get_last_error().unwrap_or(\"Unknown error\".to_string())),\n        }\n    }\n}\n\n/// Sets viewport dimensions. All sprite position and size calculations will be\n/// based on them. In most cases, you should pass the window size in pixels here,\n/// or a scaled value for pixel-art based games, for example.\npub fn set_viewport(width: u32, height: u32) -> CallResult {\n    unsafe { wrap_result(BLZ_SetViewport(width as i32, height as i32)) }\n}\n\n/// Sets the color which is used for clearing the framebuffer.\npub fn set_clear_color(color: Color) {\n    unsafe {\n        BLZ_SetClearColor(color.into());\n    }\n}\n\n/// Clears the current framebuffer.\npub fn clear() {\n    unsafe {\n        BLZ_Clear();\n    }\n}\n","traces":[{"line":147,"address":4221856,"length":1,"stats":{"Line":0}},{"line":170,"address":4218064,"length":1,"stats":{"Line":1}},{"line":172,"address":4218081,"length":1,"stats":{"Line":1}},{"line":173,"address":4218105,"length":1,"stats":{"Line":2}},{"line":200,"address":4218144,"length":1,"stats":{"Line":1}},{"line":202,"address":4218159,"length":1,"stats":{"Line":1}},{"line":203,"address":4218222,"length":1,"stats":{"Line":1}},{"line":204,"address":4218242,"length":1,"stats":{"Line":0}},{"line":212,"address":4218448,"length":1,"stats":{"Line":1}},{"line":213,"address":4218463,"length":1,"stats":{"Line":1}},{"line":217,"address":4218528,"length":1,"stats":{"Line":1}},{"line":219,"address":4218532,"length":1,"stats":{"Line":1}},{"line":224,"address":4218592,"length":1,"stats":{"Line":1}},{"line":226,"address":4218593,"length":1,"stats":{"Line":1}}],"covered":12,"coverable":14},{"path":["/","home","razer","vscode-projects","blaze-rs","src","rendertarget.rs"],"content":"use crate::internal::*;\nuse crate::texture::*;\nuse crate::*;\nuse std::marker::PhantomData;\n\n/// Defines a render target, which is, basically, an offscreen buffer\n/// that can be used as a texture.\npub struct RenderTarget<'a> {\n    pub(crate) raw: *mut BLZ_RenderTarget,\n    /// Underlying texture\n    pub texture: Texture<'a>,\n    _marker: PhantomData<&'a ()>,\n    /// Width in pixels\n    pub width: u32,\n    /// Height in pixels\n    pub height: u32,\n}\n\nimpl<'a> Drop for RenderTarget<'a> {\n    fn drop(&mut self) {\n        unsafe {\n            BLZ_FreeRenderTarget(self.raw);\n        }\n    }\n}\n\nimpl<'a> RenderTarget<'a> {\n    /// Creates a render target with specified size.\n    pub fn create(width: u32, height: u32) -> Result<RenderTarget<'a>, String> {\n        unsafe {\n            let ptr = BLZ_CreateRenderTarget(width as i32, height as i32);\n            if ptr.is_null() {\n                Err(try_get_err())\n            } else {\n                let val = *ptr;\n                Ok(RenderTarget {\n                    raw: ptr,\n                    texture: Texture {\n                        id: val.texture.id,\n                        width,\n                        height,\n                        raw: (ptr as *mut u32).offset(1) as *mut BLZ_Texture,\n                        _marker: PhantomData,\n                        no_free: true,\n                    },\n                    _marker: PhantomData,\n                    width,\n                    height,\n                })\n            }\n        }\n    }\n\n    /// Binds or unbinds (if None is passed) a render target as drawing surface.\n    pub fn bind(target: Option<&RenderTarget<'a>>) -> CallResult {\n        unsafe {\n            if let Some(t) = target {\n                wrap_result(BLZ_BindRenderTarget(t.raw))\n            } else {\n                wrap_result(BLZ_BindRenderTarget(std::ptr::null_mut()))\n            }\n        }\n    }\n}\n","traces":[{"line":20,"address":4233616,"length":1,"stats":{"Line":1}},{"line":22,"address":4233625,"length":1,"stats":{"Line":1}},{"line":29,"address":4233648,"length":1,"stats":{"Line":1}},{"line":31,"address":4233666,"length":1,"stats":{"Line":1}},{"line":32,"address":4233697,"length":1,"stats":{"Line":1}},{"line":33,"address":4233721,"length":1,"stats":{"Line":1}},{"line":34,"address":null,"length":0,"stats":{"Line":0}},{"line":35,"address":4233733,"length":1,"stats":{"Line":1}},{"line":36,"address":4233930,"length":1,"stats":{"Line":1}},{"line":37,"address":4233755,"length":1,"stats":{"Line":1}},{"line":38,"address":4233871,"length":1,"stats":{"Line":1}},{"line":39,"address":4233760,"length":1,"stats":{"Line":1}},{"line":40,"address":4233764,"length":1,"stats":{"Line":1}},{"line":41,"address":4233768,"length":1,"stats":{"Line":1}},{"line":42,"address":4233772,"length":1,"stats":{"Line":1}},{"line":43,"address":null,"length":0,"stats":{"Line":0}},{"line":44,"address":null,"length":0,"stats":{"Line":0}},{"line":46,"address":null,"length":0,"stats":{"Line":0}},{"line":47,"address":4233916,"length":1,"stats":{"Line":1}},{"line":48,"address":4233920,"length":1,"stats":{"Line":1}},{"line":55,"address":4234064,"length":1,"stats":{"Line":1}},{"line":57,"address":4234080,"length":1,"stats":{"Line":1}},{"line":58,"address":4234133,"length":1,"stats":{"Line":1}},{"line":59,"address":null,"length":0,"stats":{"Line":0}},{"line":60,"address":4234111,"length":1,"stats":{"Line":1}}],"covered":20,"coverable":25},{"path":["/","home","razer","vscode-projects","blaze-rs","src","shader.rs"],"content":"use crate::internal::*;\nuse crate::*;\nuse std::marker::PhantomData;\n\n/// Defines type for shader uniform location type.\npub type UniformLoc = i32;\n\n/// Defines a handle to a custom shader.\npub struct Shader<'a> {\n    pub(crate) raw: *mut BLZ_Shader,\n    pub(crate) _marker: PhantomData<&'a ()>,\n    /// Indicates if this is a default shader or not.\n    pub is_default: bool,\n}\n\nimpl<'a> Drop for Shader<'a> {\n    fn drop(&mut self) {\n        if self.is_default {\n            return;\n        }\n        unsafe {\n            BLZ_FreeShader(self.raw);\n        }\n    }\n}\n\nimpl<'a> Shader<'a> {\n    /// Compiles a new shader.\n    pub fn compile(vertex: &str, fragment: &str) -> Result<Shader<'a>, String> {\n        unsafe {\n            let vert = CString::new(vertex).map_err(|_| \"String contains null bytes\")?;\n            let frag = CString::new(fragment).map_err(|_| \"String contains null bytes\")?;\n            let ptr = BLZ_CompileShader(vert.as_ptr(), frag.as_ptr());\n            if ptr.is_null() {\n                Err(try_get_err())\n            } else {\n                Ok(Shader { raw: ptr, _marker: PhantomData, is_default: false })\n            }\n        }\n    }\n\n    /// Returns the default shader used by library.\n    pub fn get_default() -> Shader<'a> {\n        unsafe { Shader { raw: BLZ_GetDefaultShader(), _marker: PhantomData, is_default: true } }\n    }\n\n    /// Sets this shader as current.\n    pub fn make_current(&self) -> CallResult {\n        unsafe { wrap_result(BLZ_UseShader(self.raw)) }\n    }\n\n    /// Returns the location of an uniform variable with specified name for\n    /// the current shader.\n    pub fn get_uniform_location(&self, name: &str) -> Option<UniformLoc> {\n        unsafe {\n            let name_ptr = CString::new(name).ok()?;\n            match BLZ_GetUniformLocation(self.raw, name_ptr.as_ptr()) {\n                x if x >= 0 => Some(x),\n                _ => None,\n            }\n        }\n    }\n\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform1f(location: UniformLoc, v0: f32) {\n        unsafe {\n            BLZ_Uniform1f(location, v0);\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform2f(location: UniformLoc, v0: f32, v1: f32) {\n        unsafe {\n            BLZ_Uniform2f(location, v0, v1);\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform3f(location: UniformLoc, v0: f32, v1: f32, v2: f32) {\n        unsafe {\n            BLZ_Uniform3f(location, v0, v1, v2);\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform4f(location: UniformLoc, v0: f32, v1: f32, v2: f32, v3: f32) {\n        unsafe {\n            BLZ_Uniform4f(location, v0, v1, v2, v3);\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform1i(location: UniformLoc, v0: i32) {\n        unsafe {\n            BLZ_Uniform1i(location, v0);\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform2i(location: UniformLoc, v0: i32, v1: i32) {\n        unsafe {\n            BLZ_Uniform2i(location, v0, v1);\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform3i(location: UniformLoc, v0: i32, v1: i32, v2: i32) {\n        unsafe {\n            BLZ_Uniform3i(location, v0, v1, v2);\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform4i(location: UniformLoc, v0: i32, v1: i32, v2: i32, v3: i32) {\n        unsafe {\n            BLZ_Uniform4i(location, v0, v1, v2, v3);\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform1ui(location: UniformLoc, v0: u32) {\n        unsafe {\n            BLZ_Uniform1ui(location, v0);\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform2ui(location: UniformLoc, v0: u32, v1: u32) {\n        unsafe {\n            BLZ_Uniform2ui(location, v0, v1);\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform3ui(location: UniformLoc, v0: u32, v1: u32, v2: u32) {\n        unsafe {\n            BLZ_Uniform3ui(location, v0, v1, v2);\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform4ui(location: UniformLoc, v0: u32, v1: u32, v2: u32, v3: u32) {\n        unsafe {\n            BLZ_Uniform4ui(location, v0, v1, v2, v3);\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform_matrix_2fv(\n        location: UniformLoc,\n        count: i32,\n        transpose: bool,\n        value: &[f32],\n    ) {\n        unsafe {\n            BLZ_UniformMatrix2fv(location, count, transpose as u8, value.as_ptr());\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform_matrix_3fv(\n        location: UniformLoc,\n        count: i32,\n        transpose: bool,\n        value: &[f32],\n    ) {\n        unsafe {\n            BLZ_UniformMatrix3fv(location, count, transpose as u8, value.as_ptr());\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform_matrix_4fv(\n        location: UniformLoc,\n        count: i32,\n        transpose: bool,\n        value: &[f32],\n    ) {\n        unsafe {\n            BLZ_UniformMatrix4fv(location, count, transpose as u8, value.as_ptr());\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform_matrix_2x3fv(\n        location: UniformLoc,\n        count: i32,\n        transpose: bool,\n        value: &[f32],\n    ) {\n        unsafe {\n            BLZ_UniformMatrix2x3fv(location, count, transpose as u8, value.as_ptr());\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform_matrix_3x2fv(\n        location: UniformLoc,\n        count: i32,\n        transpose: bool,\n        value: &[f32],\n    ) {\n        unsafe {\n            BLZ_UniformMatrix3x2fv(location, count, transpose as u8, value.as_ptr());\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform_matrix_2x4fv(\n        location: UniformLoc,\n        count: i32,\n        transpose: bool,\n        value: &[f32],\n    ) {\n        unsafe {\n            BLZ_UniformMatrix2x4fv(location, count, transpose as u8, value.as_ptr());\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform_matrix_4x2fv(\n        location: UniformLoc,\n        count: i32,\n        transpose: bool,\n        value: &[f32],\n    ) {\n        unsafe {\n            BLZ_UniformMatrix4x2fv(location, count, transpose as u8, value.as_ptr());\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform_matrix_3x4fv(\n        location: UniformLoc,\n        count: i32,\n        transpose: bool,\n        value: &[f32],\n    ) {\n        unsafe {\n            BLZ_UniformMatrix3x4fv(location, count, transpose as u8, value.as_ptr());\n        }\n    }\n    /// Sets a uniform value for the currently used shader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub fn set_uniform_matrix_4x3fv(\n        location: UniformLoc,\n        count: i32,\n        transpose: bool,\n        value: &[f32],\n    ) {\n        unsafe {\n            BLZ_UniformMatrix4x3fv(location, count, transpose as u8, value.as_ptr());\n        }\n    }\n}\n","traces":[{"line":17,"address":4247664,"length":1,"stats":{"Line":1}},{"line":18,"address":4247673,"length":1,"stats":{"Line":1}},{"line":19,"address":4247684,"length":1,"stats":{"Line":1}},{"line":22,"address":4247686,"length":1,"stats":{"Line":1}},{"line":29,"address":4247728,"length":1,"stats":{"Line":1}},{"line":31,"address":4234320,"length":1,"stats":{"Line":1}},{"line":32,"address":4234352,"length":1,"stats":{"Line":1}},{"line":33,"address":4248454,"length":1,"stats":{"Line":1}},{"line":34,"address":4248589,"length":1,"stats":{"Line":1}},{"line":35,"address":4248626,"length":1,"stats":{"Line":0}},{"line":36,"address":null,"length":0,"stats":{"Line":0}},{"line":37,"address":4248633,"length":1,"stats":{"Line":1}},{"line":43,"address":4248960,"length":1,"stats":{"Line":1}},{"line":44,"address":4248964,"length":1,"stats":{"Line":1}},{"line":48,"address":4249008,"length":1,"stats":{"Line":1}},{"line":49,"address":4249020,"length":1,"stats":{"Line":1}},{"line":54,"address":4249088,"length":1,"stats":{"Line":1}},{"line":56,"address":4249110,"length":1,"stats":{"Line":1}},{"line":57,"address":4249441,"length":1,"stats":{"Line":1}},{"line":58,"address":4249529,"length":1,"stats":{"Line":1}},{"line":59,"address":4249558,"length":1,"stats":{"Line":0}}],"covered":18,"coverable":21},{"path":["/","home","razer","vscode-projects","blaze-rs","src","static.rs"],"content":"use crate::internal::*;\nuse crate::texture::*;\nuse crate::*;\nuse std::marker::PhantomData;\n\n/// Defines a static sprite batching object.\n///\n/// Designed for static geometry.\n/// The sprites are put into static VAO and use the same specified texture.\n/// Useful for static geometry like tilemaps, which do not change over time.\n/// It's possible to transform the geometry by supplying a transform matrix.\n/// The sprites are 'baked' into the GPU memory when they are first presented\n/// and cannot be modified afterwards.\npub struct StaticBatch<'b, 't: 'b> {\n    raw: *mut BLZ_StaticBatch,\n    _marker: PhantomData<&'b ()>,\n    options: StaticBatchOpts<'t>,\n}\n\n/// Defines creation options for static sprite batching object (StaticBatch).\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct StaticBatchOpts<'a> {\n    /// Texture that should be used by this batch\n    pub texture: &'a Texture<'a>,\n    /// Maximum sprite count\n    pub max_sprites: u32,\n}\n\nimpl<'b, 't: 'b> Drop for StaticBatch<'b, 't> {\n    fn drop(&mut self) {\n        unsafe {\n            BLZ_FreeBatchStatic(self.raw);\n        }\n    }\n}\n\nimpl<'b, 't: 'b> StaticBatch<'b, 't> {\n    /// Creates a new StaticBatch using specified options.\n    pub fn new(options: StaticBatchOpts<'t>) -> Result<StaticBatch<'b, 't>, String> {\n        unsafe {\n            let ptr = BLZ_CreateStatic(options.texture.raw, options.max_sprites as i32);\n            if ptr.is_null() {\n                return Err(try_get_err());\n            } else {\n                return Ok(StaticBatch { raw: ptr, _marker: PhantomData, options: options });\n            }\n        }\n    }\n\n    /// Pushes a sprite into the batch using the specified parameters.\n    /// Returns error if the batch limits are reached.\n    ///\n    /// # Parameters\n    /// `position` -\tPosition of the sprite (top-left corner if origin is NULL)\n    /// `srcRectangle` -\tPart of the source texture to draw defined in pixels, or NULL if the whole texture should be drawn\n    /// `rotation` -\tRotation of the sprite in clockwise direction in radians\n    /// `origin` -\tThe point around which the sprite should be positioned and rotated, if NULL, top-left corner (0, 0) will be used\n    /// `scale` -\tScale in X and Y directions, if NULL, defaults to (1,1)\n    /// `color` -\tColor to apply to the sprite (color gets multiplied if default shader is used)\n    /// `effects` -\tDefines if the sprite should be flipped in any direction \n    pub fn draw(\n        &self,\n        position: Vector2,\n        srcRectangle: Option<Rectangle>,\n        rotationInRadians: f32,\n        origin: Option<Vector2>,\n        scale: Option<Vector2>,\n        color: Color,\n        flip: SpriteFlip,\n    ) -> CallResult {\n        unsafe {\n            wrap_result(BLZ_DrawStatic(\n                self.raw,\n                position.into(),\n                srcRectangle.map(|r| r.into()).as_raw(),\n                rotationInRadians,\n                origin.map(|v| v.into()).as_raw(),\n                scale.map(|v| v.into()).as_raw(),\n                color.into(),\n                flip as u32,\n            ))\n        }\n    }\n\n    /// Lower-level drawing function, which allows specifying a custom quad to\n    /// be drawn. Used internally by the library.\n    pub fn lower_draw(&self, quad: &SpriteQuad) -> CallResult {\n        let q: BLZ_SpriteQuad = quad.into();\n        unsafe { wrap_result(BLZ_LowerDrawStatic(self.raw, &q)) }\n    }\n\n    /// Flushes the batch onto the screen, drawing everything.    \n    pub fn present(&self, transformMatrix: &[f32; 16]) -> CallResult {\n        unsafe {\n            let matrix_ptr: *const f32 = transformMatrix as *const f32;\n            wrap_result(BLZ_PresentStatic(self.raw, matrix_ptr))\n        }\n    }\n\n    /// Returns options which were used when this object was created.\n    pub fn get_options(&self) -> &StaticBatchOpts {\n        &self.options\n    }\n}\n","traces":[{"line":30,"address":4266048,"length":1,"stats":{"Line":1}},{"line":32,"address":4266057,"length":1,"stats":{"Line":1}},{"line":39,"address":4266080,"length":1,"stats":{"Line":1}},{"line":41,"address":4266096,"length":1,"stats":{"Line":1}},{"line":42,"address":4266134,"length":1,"stats":{"Line":1}},{"line":43,"address":4266158,"length":1,"stats":{"Line":0}},{"line":44,"address":null,"length":0,"stats":{"Line":0}},{"line":45,"address":4266170,"length":1,"stats":{"Line":1}},{"line":61,"address":4266288,"length":1,"stats":{"Line":1}},{"line":72,"address":4266695,"length":1,"stats":{"Line":1}},{"line":73,"address":4266332,"length":1,"stats":{"Line":1}},{"line":74,"address":4266340,"length":1,"stats":{"Line":1}},{"line":75,"address":4266414,"length":1,"stats":{"Line":2}},{"line":76,"address":4266486,"length":1,"stats":{"Line":1}},{"line":77,"address":4266500,"length":1,"stats":{"Line":2}},{"line":78,"address":4266571,"length":1,"stats":{"Line":2}},{"line":79,"address":4266636,"length":1,"stats":{"Line":1}},{"line":80,"address":4266680,"length":1,"stats":{"Line":1}},{"line":87,"address":4266816,"length":1,"stats":{"Line":0}},{"line":88,"address":4266836,"length":1,"stats":{"Line":0}},{"line":89,"address":4266864,"length":1,"stats":{"Line":0}},{"line":93,"address":4266928,"length":1,"stats":{"Line":1}},{"line":95,"address":4266945,"length":1,"stats":{"Line":1}},{"line":96,"address":4266955,"length":1,"stats":{"Line":1}},{"line":101,"address":4267024,"length":1,"stats":{"Line":1}},{"line":102,"address":4267029,"length":1,"stats":{"Line":1}}],"covered":21,"coverable":26},{"path":["/","home","razer","vscode-projects","blaze-rs","src","texture.rs"],"content":"use crate::internal::*;\nuse crate::*;\nuse bytes::*;\nuse std::ffi::*;\nuse std::marker::PhantomData;\n\n/// Defines a texture.\n#[derive(Debug, PartialEq, Eq)]\npub struct Texture<'a> {\n    /// OpenGL texture ID\n    pub id: u32,\n    /// Width in pixels\n    pub width: u32,\n    /// Height in pixels\n    pub height: u32,\n    pub(crate) raw: *mut BLZ_Texture,\n    pub(crate) _marker: PhantomData<&'a ()>,\n    pub(crate) no_free: bool,\n}\n\nenum_from_primitive! {\n    /// Defines which channels the image loader should load when an image is\n    /// being read from file or memory.\n    #[cfg_attr(tarpaulin, skip)]\n    #[derive(Debug, PartialEq)]\n    pub enum ImageChannels\n    {\n        /// Load channels as defined by image data (mostly used)\n        Auto = BLZ_ImageChannels_AUTO as isize,\n        /// Load as grayscale\n        Grayscale = BLZ_ImageChannels_GRAYSCALE as isize,\n        /// Load as grayscale alpha\n        GrayscaleAlpha = BLZ_ImageChannels_GRAYSCALE_ALPHA as isize,\n        /// Load red, green and blue channels\n        RGB = BLZ_ImageChannels_RGB as isize,\n        /// Load red, green, blue and alpha channels\n        RGBA = BLZ_ImageChannels_RGBA as isize\n    }\n}\n\nbitflags! {\n    /// Defines various flags that can be supplied to image loader.\n    #[cfg_attr(tarpaulin, skip)]\n    pub struct ImageFlags: u32 {\n        /// Default flags\n        const None = 0;\n        /// Force power-of-two textures\n        const PowerOfTwo  = BLZ_ImageFlags_POWER_OF_TWO;\n        /// Generate mipmaps\n        const Mipmaps = BLZ_ImageFlags_MIPMAPS;\n        /// Make texture repeated\n        const Repeats = BLZ_ImageFlags_TEXTURE_REPEATS;\n        /// Multiply alpha\n        const MultiplyAlpha = BLZ_ImageFlags_MULTIPLY_ALPHA;\n        /// Invert texture by Y axis (vertically)\n        const InvertY = BLZ_ImageFlags_INVERT_Y;\n        /// Compress to DXT format\n        const CompressToDXT = BLZ_ImageFlags_COMPRESS_TO_DXT;\n        /// Load as DDS\n        const DDSLoadDirect = BLZ_ImageFlags_DDS_LOAD_DIRECT;\n        /// Force safe RGB values\n        const NTSCSafeRGB = BLZ_ImageFlags_NTSC_SAFE_RGB;\n        /// Load as CoCgY\n        const CoCgY = BLZ_ImageFlags_CoCg_Y;\n        /// Use texture rectangle OpenGL extension\n        const TextureRectangle = BLZ_ImageFlags_TEXTURE_RECTANGLE;\n    }\n}\n\nenum_from_primitive! {\n    /// Defines supported formats for saving images.\n    #[cfg_attr(tarpaulin, skip)]\n    #[derive(Debug, PartialEq)]\n    pub enum SaveImageFormat\n    {\n        /// TGA\n        TGA = BLZ_SaveImageFormat_TGA as isize,\n        /// BMP\n        BMP = BLZ_SaveImageFormat_BMP as isize,\n        /// DDS\n        DDS = BLZ_SaveImageFormat_DDS as isize\n    }\n}\n\nenum_from_primitive! {\n    /// Defines texture filtering options.\n    #[cfg_attr(tarpaulin, skip)]\n    #[derive(Debug, PartialEq)]\n    pub enum TextureFilter {\n        /// Use nearest filtering (good for pixel-art)\n        Nearest = BLZ_TextureFilter_NEAREST as isize,\n        /// Use linear filtering (smoothes scaled textures)\n        Linear = BLZ_TextureFilter_LINEAR as isize,\n    }\n}\n\nenum_from_primitive! {\n    /// Defines texture wrapping options.\n    #[cfg_attr(tarpaulin, skip)]\n    #[derive(Debug, PartialEq)]\n    pub enum TextureWrap {\n        /// Clamp to edge (no repeat)\n        ClampToEdge = BLZ_TextureWrap_CLAMP_TO_EDGE as isize,\n        /// Repeat\n        Repeat = BLZ_TextureWrap_REPEAT as isize,\n        /// Repeat with mirroring\n        MirroredRepeat = BLZ_TextureWrap_MIRRORED_REPEAT as isize,\n    }\n}\n\nimpl<'a> Drop for Texture<'a> {\n    fn drop(&mut self) {\n        unsafe {\n            if !self.no_free {\n                BLZ_FreeTexture(self.raw);\n            }\n        }\n    }\n}\n\nunsafe fn from_ptr<'a>(ptr: *mut BLZ_Texture) -> Result<Texture<'a>, String> {\n    if ptr.is_null() {\n        Err(try_get_err())\n    } else {\n        let tex = *ptr;\n        Ok(Texture {\n            raw: ptr,\n            _marker: PhantomData,\n            id: tex.id,\n            width: tex.width as u32,\n            height: tex.height as u32,\n            no_free: false,\n        })\n    }\n}\n\nfn path_to_ptr(path: &str) -> Result<CString, String> {\n    CString::new(path.to_owned()).map_err(|_| \"Path cannot be null\".to_owned())\n}\n\nimpl<'a> Texture<'a> {\n    /// Sets the texture filtering options for this texture when the texture is\n    /// minified and magnified.\n    pub fn set_filtering(\n        &self,\n        minification: TextureFilter,\n        magnification: TextureFilter,\n    ) -> CallResult {\n        unsafe {\n            wrap_result(BLZ_SetTextureFiltering(\n                self.raw,\n                minification as u32,\n                magnification as u32,\n            ))\n        }\n    }\n\n    /// Sets the texture wrapping options for each axis.\n    pub fn set_wrap(&self, x: TextureWrap, y: TextureWrap) -> CallResult {\n        unsafe { wrap_result(BLZ_SetTextureWrap(self.raw, x as u32, y as u32)) }\n    }\n\n    /// Loads a texture from memory. A supported image file data must be supplied.\n    pub fn from_memory(\n        bytes: &Bytes,\n        channels: ImageChannels,\n        texture_id: Option<u32>,\n        flags: ImageFlags,\n    ) -> Result<Texture<'a>, String> {\n        unsafe {\n            if let Some(i) = texture_id {\n                if i <= 0 {\n                    return Err(\"Invalid texture ID, must be greater than zero\".to_owned());\n                }\n            }\n            let buf_ptr = bytes.as_ptr();\n            let ptr = BLZ_LoadTextureFromMemory(\n                buf_ptr,\n                bytes.len() as i32,\n                channels as u32,\n                match texture_id {\n                    Some(i) => i,\n                    None => 0,\n                },\n                flags.bits,\n            );\n            from_ptr(ptr)\n        }\n    }\n\n    /// Loads a texture from file. A supported image file must be supplied.\n    pub fn from_file(\n        path: &str,\n        channels: ImageChannels,\n        texture_id: Option<u32>,\n        flags: ImageFlags,\n    ) -> Result<Texture<'a>, String> {\n        unsafe {\n            if let Some(i) = texture_id {\n                if i <= 0 {\n                    return Err(\"Invalid texture ID, must be greater than zero\".to_owned());\n                }\n            }\n            let path_ptr = path_to_ptr(path);\n            if let Ok(p) = path_ptr {\n                return from_ptr(BLZ_LoadTextureFromFile(\n                    p.as_ptr(),\n                    channels as u32,\n                    match texture_id {\n                        Some(i) => i,\n                        None => 0,\n                    },\n                    flags.bits,\n                ));\n            } else {\n                return Err(\"Invalid path\".to_owned());\n            }\n        }\n    }\n\n    /// Returns maximum available slots for multitexturing.\n    pub fn get_max_slots() -> u32 {\n        unsafe { BLZ_GetMaxTextureSlots() as u32 }\n    }\n\n    /// Binds or unbinds a texture to specified slot, starting from slot 0.\n    /// If a texture is bound to slot 0, it overrides the texture used by\n    /// draw calls.\n    pub fn bind(texture: Option<&Texture>, slot: u32) -> CallResult {\n        unsafe {\n            if let Some(tex) = texture {\n                wrap_result(BLZ_BindTexture(tex.raw, slot as i32))\n            } else {\n                wrap_result(BLZ_BindTexture(std::ptr::null_mut(), slot as i32))\n            }\n        }\n    }\n}\n\n/// Saves a screenshot of specified window region to file.\npub fn save_screenshot(\n    path: &str,\n    format: SaveImageFormat,\n    x_start: u32,\n    y_start: u32,\n    width: u32,\n    height: u32,\n) -> CallResult {\n    let path_ptr = path_to_ptr(path);\n    unsafe {\n        match path_ptr {\n            Ok(p) => wrap_result(BLZ_SaveScreenshot(\n                p.as_ptr(),\n                format as u32,\n                x_start as i32,\n                y_start as i32,\n                width as i32,\n                height as i32,\n            )),\n            Err(s) => Err(s),\n        }\n    }\n}\n","traces":[{"line":25,"address":4294192,"length":1,"stats":{"Line":0}},{"line":41,"address":4302200,"length":1,"stats":{"Line":0}},{"line":73,"address":4303472,"length":1,"stats":{"Line":0}},{"line":88,"address":4304464,"length":1,"stats":{"Line":0}},{"line":100,"address":4305232,"length":1,"stats":{"Line":0}},{"line":112,"address":4289552,"length":1,"stats":{"Line":1}},{"line":114,"address":4289561,"length":1,"stats":{"Line":1}},{"line":115,"address":4289577,"length":1,"stats":{"Line":1}},{"line":121,"address":4289616,"length":1,"stats":{"Line":1}},{"line":122,"address":4289628,"length":1,"stats":{"Line":1}},{"line":123,"address":4289665,"length":1,"stats":{"Line":1}},{"line":125,"address":4289677,"length":1,"stats":{"Line":1}},{"line":126,"address":4289714,"length":1,"stats":{"Line":1}},{"line":127,"address":4289697,"length":1,"stats":{"Line":1}},{"line":129,"address":4289702,"length":1,"stats":{"Line":1}},{"line":130,"address":4289706,"length":1,"stats":{"Line":1}},{"line":131,"address":4289710,"length":1,"stats":{"Line":1}},{"line":137,"address":4289840,"length":1,"stats":{"Line":1}},{"line":138,"address":4231968,"length":1,"stats":{"Line":1}},{"line":144,"address":4289936,"length":1,"stats":{"Line":1}},{"line":150,"address":4289995,"length":1,"stats":{"Line":1}},{"line":151,"address":4289966,"length":1,"stats":{"Line":1}},{"line":152,"address":4289974,"length":1,"stats":{"Line":1}},{"line":153,"address":4289982,"length":1,"stats":{"Line":1}},{"line":159,"address":4290048,"length":1,"stats":{"Line":1}},{"line":160,"address":4290078,"length":1,"stats":{"Line":1}},{"line":164,"address":4290160,"length":1,"stats":{"Line":1}},{"line":171,"address":4290195,"length":1,"stats":{"Line":1}},{"line":172,"address":4290225,"length":1,"stats":{"Line":0}},{"line":173,"address":4290263,"length":1,"stats":{"Line":0}},{"line":176,"address":4290234,"length":1,"stats":{"Line":1}},{"line":177,"address":4290492,"length":1,"stats":{"Line":1}},{"line":178,"address":4290361,"length":1,"stats":{"Line":1}},{"line":179,"address":4290369,"length":1,"stats":{"Line":1}},{"line":180,"address":4290399,"length":1,"stats":{"Line":1}},{"line":181,"address":4290458,"length":1,"stats":{"Line":1}},{"line":182,"address":4290404,"length":1,"stats":{"Line":1}},{"line":183,"address":4290447,"length":1,"stats":{"Line":1}},{"line":185,"address":4290487,"length":1,"stats":{"Line":1}},{"line":187,"address":4290526,"length":1,"stats":{"Line":1}},{"line":192,"address":4290560,"length":1,"stats":{"Line":1}},{"line":199,"address":4290603,"length":1,"stats":{"Line":1}},{"line":200,"address":4290672,"length":1,"stats":{"Line":0}},{"line":201,"address":4290721,"length":1,"stats":{"Line":0}},{"line":204,"address":4290681,"length":1,"stats":{"Line":1}},{"line":205,"address":4290801,"length":1,"stats":{"Line":1}},{"line":206,"address":4291049,"length":1,"stats":{"Line":1}},{"line":207,"address":4290898,"length":1,"stats":{"Line":1}},{"line":208,"address":4290957,"length":1,"stats":{"Line":1}},{"line":209,"address":4291013,"length":1,"stats":{"Line":1}},{"line":210,"address":4290962,"length":1,"stats":{"Line":1}},{"line":211,"address":4291002,"length":1,"stats":{"Line":1}},{"line":213,"address":4291042,"length":1,"stats":{"Line":1}},{"line":215,"address":null,"length":0,"stats":{"Line":0}},{"line":216,"address":4290812,"length":1,"stats":{"Line":0}},{"line":222,"address":4291456,"length":1,"stats":{"Line":1}},{"line":223,"address":4291457,"length":1,"stats":{"Line":1}},{"line":229,"address":4291488,"length":1,"stats":{"Line":1}},{"line":231,"address":4291509,"length":1,"stats":{"Line":1}},{"line":232,"address":4291562,"length":1,"stats":{"Line":1}},{"line":233,"address":null,"length":0,"stats":{"Line":0}},{"line":234,"address":4291540,"length":1,"stats":{"Line":1}},{"line":241,"address":4291648,"length":1,"stats":{"Line":1}},{"line":249,"address":4291700,"length":1,"stats":{"Line":1}},{"line":251,"address":4292186,"length":1,"stats":{"Line":1}},{"line":252,"address":4291799,"length":1,"stats":{"Line":1}},{"line":253,"address":4291886,"length":1,"stats":{"Line":1}},{"line":254,"address":4292121,"length":1,"stats":{"Line":1}},{"line":255,"address":4292126,"length":1,"stats":{"Line":1}},{"line":256,"address":4292130,"length":1,"stats":{"Line":1}},{"line":257,"address":4292134,"length":1,"stats":{"Line":1}},{"line":258,"address":4292142,"length":1,"stats":{"Line":1}},{"line":260,"address":4291906,"length":1,"stats":{"Line":0}}],"covered":60,"coverable":73}]};</script>
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = [...files[0].path];
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
    }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    const commonPath = findCommonPath(data.files);
    const files = data.files.map(file => ({...file, path: file.path.slice(commonPath.length), parent: commonPath}));
    const children = findFolders(files);

    data = {
      is_folder: true,
      children,
      path: commonPath,
      parent: [],
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    };

    this.state = {
      commonPath,
      current: [data],
    };
  }

  render() {
    const {current} = this.state;
    if (!current || !current.length) {
      return null;
    }
    const file = current[current.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: current.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file]};
    });
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    });
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : '')
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + (file.covered / file.coverable * 100).toFixed(2) + '%)' : '')
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

ReactDOM.render(e(App), document.getElementById('root'));
</script>
</body>
</html>